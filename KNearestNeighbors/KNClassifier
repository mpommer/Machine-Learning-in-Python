# -*- coding: utf-8 -*-
"""
Created on Sun May  9 09:21:15 2021

@author: Marcel Pommer
"""

import numpy as np
import warnings
import pandas as pd
from collections import Counter

class knearestNeighbors:
    def __init__(self, data):
        self.data = data
        
    def fit(self, predictions, numberNearestNeighbors = 3):
        data = self.data
        labels = data.iloc[: , -1].drop_duplicates(keep='first', inplace=False)
        data_dict = {x:[] for x in labels}
        for index, i in data.iterrows():
            data_dict[i[data.shape[1]-1]].append(i[:-1].values)
            
        if len(data_dict) >=numberNearestNeighbors:
            warnings.warn('K is set to value less than number of groups')
        
        predicted_group = []
        confidence = []
        # loop over all predictions
        for index in range(len(predictions)):
            predict = predictions.iloc[index].to_numpy()
            
            # get distances 
            distances = []
            for group in data_dict:
                for features in data_dict[group]:
                    # calculate euclidean distance
                    euclidean_distance = np.linalg.norm(np.array(features) - np.array(predict))
                    distances.append([euclidean_distance, group])
               
            # analyze the distance
            votes = [i[1] for i in sorted(distances)[:numberNearestNeighbors]]
            
            vote_result = Counter(votes).most_common(1)[0][0]
            predicted_group.append(vote_result)
            confidence.append(vote_result/numberNearestNeighbors)
    
        self.confidence = confidence
        self.predictions = predicted_group
        return predicted_group
    
    def getConfidence(self, predictions, numberNearestNeighbors=3, new_prediction = False):
        if new_prediction == True or self.confidence == None:
              self.fit(predictions = predictions, numberNearestNeighbors = numberNearestNeighbors)
        return self.confidence
    
    def getAccuracy(self, predictions, y_test, numberNearestNeighbors=3, new_prediction = False):
        if new_prediction == True or self.predictions == None:
            self.fit(predictions = predictions, numberNearestNeighbors = numberNearestNeighbors)
        
        pred = self.predictions
        correct = [True for i in range(len(pred)) if (pred[i]==y_test[i])]
        
        return len(correct)/len(pred)
            
        

